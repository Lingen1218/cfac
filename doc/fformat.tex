\chapter{Description of Output Files}
\label{cha:format}
\cFAC outputs results of calculations in three formats: binary, ASCII, and as a
SQLite database. The primary format is the binary one. The binary files can be
converted to either ASCII or SQLite ones by invoking \funcref{PrintTable} and 
\funcref{StoreTable} functions, respectively.

The structure of these files is described below.

As of now (\cFAC-\facversion), the SQLite format does not support results of
magnetic-sublevel-resolved calculations. This deficiency will be fixed soon.

\section{Binary Format}
\label{sec:binary}
Presently, \cFAC produces different types of files. Each type is assigned
a unique integer, which corresponds to a macro define in the file
\verb|faclib/dbase.h|. These types are
\begin{description}
\item[\texttt{DB\_EN = 1}] Energy levels produced by the function
\verb|Structure|. 
\item[\texttt{DB\_TR = 2}] Radiative transition rates produced by
\verb|TransitionTable|.
\item[\texttt{DB\_CE = 3}] Collisional excitation cross sections produced by
\verb|CETable|. 
\item[\texttt{DB\_RR = 4}] Radiative recombination and photoionization cross
sections produced by \verb|RRTable|.
\item[\texttt{DB\_AI = 5}] Autoionization rates produced by \verb|AITable|.
\item[\texttt{DB\_CI = 6}] Collisional ionization cross sections produced by
\verb|CITable|. 
\item[\texttt{DB\_AIM = 10}] Magnetic sublevel autoionization rates and DR
capture strengths produced by \verb|AITableMSub|.
\item[\texttt{DB\_CIM = 11}] Magnetic sublevel collisional ionization cross
  sections produced by \verb|CITableMSub|.
\end{description}

All files have a common structure. It consists of a file header and one or
more data blocks. Each data block is comprised of a data header and one or
more data records. In the following, we show the C definition of all structs
and describe each field in detail. When one field is a pointer, it means that
an array is saved in the database. The pointer points to the memory location
where the data is stored. In versions 1.0.8 or earlier, the value of the
pointer itself is also saved in the file followed by the data stored in the
array. Obviously, the saved pointer itself has no meaning once the program
exits (since it is a memory location). When reading out the data from the
database file, these pointer values should be ignored. In version 1.0.9 or
later, the pointers are no longer saved, and the file IO are rewritten in a
platform independent way, i.e., the structure fields are written and read one
by one, instead of dealing with the structure as an integrated object. This
avoids the different memory padding added by the compilers which may be
different on different machines.

\subsection{\texttt{F\_HEADER}}
\index{F\_HEADER}
\texttt{F\_HEADER} is the file header common to all data files. 

\begin{verbatim}
typedef struct _F_HEADER_ {
  long  tsession;
  int   version;
  int   sversion;
  int   ssversion;
  int   type;
  float atom;
  char  symbol[4];
  int   nblocks;
} F_HEADER;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{long tsession}:] Time stamp when the file is created. This is the
value returned by the C lib function time(0). It is platform dependent. 
\item[\texttt{int version}:] Major version number of \cFAC.
\item[\texttt{int sversion}:] Minor version number of \cFAC.
\item[\texttt{int ssversion}:] Release number of \cFAC.
\item[\texttt{int type}:] Type of the data file.
\item[\texttt{float atom}:] Atomic number.
\item[\texttt{char symbol[4]}:] The first 3 bytes contains a NULL
terminated C string representing the 2-character abbreviation of the atomic
symbol. The 4th byte is either 0 or 1, indicating whether the platform stores
data in little or big endian.
\item[\texttt{int nblocks}:] Number of data blocks in this file.
\end{dbdesc}

\subsection{\texttt{EN\_HEADER}}
\index{EN\_HEADER}
\texttt{EN\_HEADER} is the data header for energy level data blocks.

\begin{verbatim}
typedef struct _EN_HEADER_ {
  long position;
  long length;
  int nele;
  int nlevels;
} EN_HEADER;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{long position}:] The number of bytes from the beginning of the
file to the place where this data block starts.
\item[\texttt{long length}:] Number of bytes in this data block, excluding the
length of the header.
\item[\texttt{int nele}:] Number of electrons in the ion for this block.
\item[\texttt{int nlevels}:] Number of levels in this block.
\end{dbdesc}

\subsection{\texttt{EN\_RECORD}}
\index{EN\_RECORD}
\texttt{EN\_RECORD} represents an energy level.

\begin{verbatim}
#define LNCOMPLEX   32
#define LSNAME      24
#define LNAME       56

typedef struct _EN_RECORD_ {
  short p;
  short j;
  int ilev;
  int ibase;
  double energy;
  char ncomplex[LNCOMPLEX];
  char sname[LSNAME];
  char name[LNAME];
} EN_RECORD;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{LNCOMPLEX}:] The length of array holding the complex name.
\item[\texttt{LSNAME}:] The length of array holding the non-relativistic
configuration name.
\item[\texttt{LNAME}:] The length of array holding the relativistic
configuration array.
\item[\texttt{short p}:] The parity of the level. This parameter was changed
in version 0.7.6, and it becomes $\pm(100\times n + l)$, where $n$ and $l$ are
the principle quantum number and orbital angular number of the valence
electron, and the $\pm$ sign indicates an even ($+$) or odd ($-$) parity state.
\item[\texttt{short j}:] 2 $\times$ the total angular momentum of the
  level. In UTA mode, \texttt{j} is supposed to be the statistical weight
  minus 1 of the UTA level. However, because a \texttt{short} variable is
  sometimes insufficient to store that value, the code stores it in
  \texttt{ibase} instead. In this case, \texttt{j} is always $-1$.
\item[\texttt{int ilev}:] The index of the level.
\item[\texttt{int ibase}:] The index of the base level. The base level
  obtained by peeling off the valence electron, and the resulting levels must
  be present in the same level file. Other wise, its value is -1. It is not
  always possible to determine the base level, e.g., when the valence orbital
  is occupied by more than one electrons. In such cases, \texttt{ibase} is
  also -1. The value of \texttt{ibase} is primarily used in dealing with DR
  and RE rates, where it may help the distinguish different resonance channels
  and facilitate easy extrapolation. This variable is only added in version
  FAC 1.0.4. So these later versions are not compatible with the binary
  output of the earlier versions.
\item[\texttt{energy}:] The energy of the level in Hartree.
\item[\texttt{char ncomplex[LNCOMPLEX]}:] The complex name. It is in the format
of \verb|n1*nq1 n2*nq2|$\cdots$, where \verb|n1| and \verb|n2| are the
principle quantum numbers of the shell, \verb|nq1| and \verb|nq2| are the
occupation number of these shells.
\item[\texttt{char sname[LSNAME]}:] The non-relativistic configuration name of
the level. Each non-relativistic shell is denoted by the standard
spectroscopic notation, e.g., \verb|2p2| for 2 electrons in $2p$ shell. Only
open and non-empty shells are given. No coupling information is available in
this name.
\item[\texttt{char name[LNAME]}:] The relativistic configuration name of the
level. Each shell is denoted such that \verb|2p+2(2)| represents 2 electrons in
$2p_{3/2}(J=1)$ and \verb|2p-2(2)| represents 2 electrons in
$2p_{1/2}(J=1)$. The number in the parenthesis is 2 times the total angular
momentum of the coupled shell. Immediately after the parenthesis, there is a
number indicate the $2J$ value when all preceding shells are
coupled. Therefore, \verb|2p+2(2)2 2p-2(2)0| represents a state
$[2p_{3/2}^{2}(J=1) 2p_{1/2}^2(J=1)]J=0$.
\end{dbdesc}

\subsection{\texttt{TR\_HEADER}}
\index{TR\_HEADER}
\texttt{TR\_HEADER} is the data header for the radiative transition data
blocks. 

\begin{verbatim}
typedef struct _TR_HEADER_ {
  long position;
  long length;
  int nele;
  int ntransitions;
  int gauge;
  int mode;
  int multipole;
} TR_HEADER;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{long position}:] The number of bytes from the beginning of the
file to the place where this data block starts.
\item[\texttt{long length}:] Number of bytes in this data block, excluding the
length of the header.
\item[\texttt{int nele}:] Number of electrons in the ion for this block.
\item[\texttt{int ntransitions}:] Number of transitions in this block.
\item[\texttt{int gauge}:] Gauge used in the calculation. 1 is Coulomb gauge, or
the velocity form in non-relativistic limit. 2 is Babushkin gauge or the
length form.
\item[\texttt{int mode}:] Mode used in the calculation. 0 is fully
relativistic. 1 is non-relativistic approximation for multipole operators.
\item[\texttt{int multipole}:] Multipole type of the transition. Its absolute
value is the rank of the multipole, 1 for dipole, 2 for quadrupole, etc. The
positive sign represents magnetic type and negative sign represents electric
type.
\end{dbdesc}

\subsection{\texttt{TR\_RECORD}}
\index{TR\_RECORD}
\texttt{TR\_RECORD} is the for radiative transition data.

\begin{verbatim}
typedef struct _TR_RECORD_ {
  int lower;
  int upper;
  float strength;
} TR_RECORD;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{int lower}:] The lower level index of the transition.
\item[\texttt{int upper}:] The upper level index of the transition.
\item[\texttt{float strength}:] In version 1.0.6 or older, This is the
  weighted oscillator strength $gf$ of the transition. The weighted radiative
  transition rate is related to $gf$ as (in atomic units):
\begin{equation}
gA = 2\alpha^3 \omega^2 gf,
\end{equation}
where $\alpha$ is the fine structure constant, and $\omega$ is transition
energy in Hartree atomic units. 

In version 1.0.7 or newer, this stores the multipole matrix elements $M$
instead. It is related to the $gf$ value as
\begin{equation}
gf =
\left(2L+1\right)^{-1}\omega\left(\alpha\omega\right)^{2L-2}\left|M\right|^2,
\end{equation}
where $L$ is the multipole rank.
\end{dbdesc}

\subsection{\texttt{TR\_EXTRA}}
\index{TR\_EXTRA}
\texttt{TR\_EXTRA} contains the UTA related transition data, namely, the
transition energy including the UTA shift, the UTA Gaussian width, and the
configuration interaction multiplier. This structure is written to the
\texttt{DB\_TR} file only in UTA mode, which is set by the \funcref{SetUTA}
function.

\begin{verbatim}
typedef struct _TR_EXTRA_ {
  float energy;
  float sdev;
  float sci;
} TR_EXTRA;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{float energy}:] The transition energy including UTA shift.
\item[\texttt{float sdev}:] The Gaussian standard deviation of the UTA.
\item[\texttt{float sci}:] The configuration interaction multiplier, which
  accounts for the CI within the same non-relativistic configurations.
\end{dbdesc}

\subsection{\texttt{CE\_HEADER}}
\index{CE\_HEADER}
\texttt{CE\_HEADER} is the data header for collisional excitation data blocks.

\begin{verbatim}
typedef struct _CE_HEADER_ {
  long position;
  long length;
  int nele;
  int ntransitions;
  int qk_mode;
  int n_tegrid;
  int n_egrid;
  int egrid_type;
  int n_usr;
  int usr_egrid_type;
  int nparams;
  int pw_type;
  int msub;
  float te0;
  double *tegrid;
  double *egrid;
  double *usr_egrid;
} CE_HEADER;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{long position}:] The number of bytes from the beginning of the
file to the place where this data block starts.
\item[\texttt{long length}:] Number of bytes in this data block, excluding the
length of the header.
\item[\texttt{int nele}:] Number of electrons in the ion for this block.
\item[\texttt{int ntransitions}:] Number of transitions in this block.
\item[\texttt{int qk\_mode}:] The mode for the calculation of radial
integrals. There are 3 choices for collisional excitation. 0 for EXACT, 1 for
INTERPOLATE, and 2 for FIT. In the EXACT mode, the collision strengths are
calculated at the energy grid specified as is, so the \texttt{egrid} and
\texttt{usr\_egrid} must be the same. In the INTERPOLATE mode, the collision
strengths are calculated at \texttt{egrid}, and interpolated to
\texttt{usr\_egrid}. In the FIT mode, the collision strengths are fitted to an
analytic formula and the parameters are output as well. For collision
strengths of magnetic sublevels, the FIT mode is not implemented.
\item[\texttt{int n\_tegrid}:] Number of points for the transition energy grid.
\item[\texttt{int n\_egrid}:] Number of points for the collision energy grid.
\item[\texttt{int egrid\_type}:] Type of the energy grid. 0 for the incident
electron energy, 1 for scattered electron energy. In the present
implementation, only scattered electron energy grid is supported.
\item[\texttt{int n\_usr}:] Number of points for the user collision energy
grid.
\item[\texttt{int usr\_egrid\_type}:] Type of the user energy grid. 0 for the
incident electron energy, 1 for scattered electron energy. In the present
implementation, only scattered electron energy grid is supported.
\item[\texttt{int nparams}:] Number of parameters in the fitting formula if the
collision strengths are calculated in the FIT mode. At present,
\texttt{nparams} is 4. 
\item[\texttt{int pw\_type}:] Partial wave type for the last summation. 0 for
the incident electron, 1 for the scattered electron.
\item[\texttt{int msub}:] 0 for total collision strength, 1 for magnetic
sublevel specific collision strength.
\item[\texttt{float te0}:] The characteristic transition energy of the 
transition array. This is used for the automatic construction of the 
collision energy grid. The grid has equal space in $\ln$(\texttt{egrid+te0})
if \texttt{egrid\_type = 1}, otherwise, this variable is not used.
\item[\texttt{double *tegrid}:] The transition energy grid, the number of
elements is given by \texttt{n\_tegrid}.
\item[\texttt{double *egrid}:] The energy grid, the number of elements is
given by \texttt{n\_egrid}.
\item[\texttt{double *usr\_egrid}:] The user energy grid, the number of
elements is given by \texttt{n\_usr}.
\end{dbdesc}

\subsection{\texttt{CE\_RECORD}}
\index{CE\_RECORD}
\texttt{CE\_RECORD} is for collisional excitation data.

\begin{verbatim}
typedef struct _CE_RECORD_ {
  int lower;
  int upper;
  int nsub;
  float bethe;
  float born[2];
  float *params;
  float *strength;
} CE_RECORD;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{int lower}:] The lower level index.
\item[\texttt{int upper}:] The upper level index.
\item[\texttt{int nsub}:] Number of magnetic sublevel transitions. Because of
time reversal symmetry, $\sigma_{m_1\to m_2}=\sigma_{-m_1\to -m_2}$, only cross
sections with $m_1 <= 0$ are tabulated.
\item[\texttt{float bethe}:] The Bethe coefficients in the first-Born
approximation. It is the logarithmic coefficients at high energies. If
\texttt{bethe[0]}$<0$, it is a spin forbidden transition. Otherwise, it is
either a optical-allowed transition or other multipole-allowed transitions.
\item[\texttt{float born[2]}:] The Born limit of the collision strengths at
high energies, which is
\begin{eqnarray}
x &=& \frac{E_0}{E_{th}} \nonumber\\
\Omega &=& b_0\ln(x) + b_1,
\end{eqnarray}
where $b_0$ is given by \texttt{bethe}, if it is an allowed transition. The
parameter $b_1$ is calculated at an energy given by $b_2$, which is chosen to
be very high, about $10^{2}E_{th}$ or higher.
For spin forbidden transitions, $b_0 = 0$. $b_1$, $b_2$ are stored in the array
\texttt{born[2]}. These numbers are useful to extrapolate the collision
strengths to high energies with correct asymptotic behavior.
\item[\texttt{float *params}:] Parameters for the fitting formula, if the
fitting mode is used. The number of elements is given by \texttt{nparams} in
\texttt{CE\_HEADER}. In the present implementation, different fitting formulae
are used for allowed and forbidden transitions. The number of parameters is 4
in all cases. The FIT mode is not robust, avoid using it.

For dipole and higher multipole allowed transitions, the
collision strength $\Omega$ is given by
\begin{eqnarray}
x &=& \frac{E_0}{E_{th}} \nonumber\\
\Omega &=& p_0\left(\frac{1}{x}\right)^{p_1} + 
p_2\left(1-\frac{1}{x}\right)^{p_3} + b\ln x,
\end{eqnarray}
where $E_0$ is the energy of the incident electron, $E_{th}$ is the transition
threshold, $p_0$, $p_1$, $p_2$ and $p_4$ are four parameters, and $b$ is the
Bethe coefficient, which is 0 for non-dipole transitions.

For forbidden transitions, the collision strength is given by
\begin{eqnarray}
\gamma &=& -2.0 + p_1\frac{1}{p_3+x} + 
p_2\left(\frac{1}{p_3+x}\right)^2\nonumber\\
\Omega &=& p_0x^\gamma.
\end{eqnarray}

The FIT mode only applies to the calculation of total cross sections. For
magnetic sublevel cross sections, \texttt{params} has \texttt{nsub} elements,
which are the ratios of magnetic sublevel collision strengths to the total
collision strength at high energy limit for allowed transitions. For forbidden
transitions, these numbers are all 0.

\item[\texttt{float *stregnth}:] Collision stregnth on the user energy
grid. The number of elements is given by \texttt{n\_usr} in
\texttt{CE\_HEADER}. It is related to the excitation cross section as (in
atomic units):
\begin{equation}
\sigma = \frac{\pi}{k_0^2g_0}\Omega,
\end{equation}
where $g_0$ is the statistical weight of the initial state, and $k_0$ is the
kinetic momentum of the incident electron. The number of elements in this
array is \texttt{nsub}$\times$\texttt{n\_usr}.
\end{dbdesc}

\subsection{\texttt{RR\_HEADER}}
\index{RR\_HEADER}
\texttt{RR\_HEADER} is the data header for radiative recombination and
photoionization data blocks.

\begin{verbatim}
typedef struct _RR_HEADER_ {
  long position;
  long length;
  int nele;
  int ntransitions;
  int qk_mode;
  int multipole;
  int n_tegrid;
  int n_egrid;
  int egrid_type;
  int n_usr;
  int usr_egrid_type;
  int nparams;
  double *tegrid;
  double *egrid;
  double *usr_egrid;
} RR_HEADER;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{long position}:] The number of bytes from the beginning of the
file to the place where this data block starts.
\item[\texttt{long length}:] Number of bytes in this data block, excluding the
length of the header.
\item[\texttt{int nele}:] Number of electrons in the ion for this block.
\item[\texttt{int ntransitions}:] Number of transitions in this block.
\item[\texttt{int qk\_mode}:] The mode for the calculation of radial
integrals. There are 3 choices at present. 0 for EXACT, 1 for INTERPOLATE, and
2 for FIT, similar to collisional excitation. However, even if the FIT
mode is used, the fitting formula is only valid in the high energy asymptotic
regions. The low energy results should be obtained by interpolation.
\item[\texttt{int multipole}:] Multipole type of the transition. Its absolute
value is the rank of the multipole, 1 for dipole, 2 for quadrupole, etc. The
positive sign for magnetic type and negative sign for electric type. Usually,
only E1 type is relevant for radiative recombination and photoionization.
\item[\texttt{int n\_tegrid}:] Number of points for the transition energy grid.
\item[\texttt{int n\_egrid}:] Number of points for the collision energy grid.
\item[\texttt{int egrid\_type}:] Type of the energy grid. 0 for the incident
photon energy, 1 for photo-electron energy.
\item[\texttt{int n\_usr}:] Number of points for the user collision energy
grid.
\item[\texttt{int usr\_egrid\_type}:] Type of the user energy grid. 0 for the
incident photon energy, 1 for photo-electron energy.
\item[\texttt{int nparams}:] Number of parameters in the fitting formula if the
bound-free oscillator strengths are calculated in the FIT mode. In the present
implementation, \texttt{nparams} is 4.
\item[\texttt{double *tegrid}:] The transition energy grid, the number of
elements is given by \texttt{n\_tegrid}.
\item[\texttt{double *egrid}:] The energy grid, the number of elements is
given by \texttt{n\_egrid}.
\item[\texttt{double *usr\_egrid}:] The user energy grid, the number of
elements is given by \texttt{n\_usr}.
\end{dbdesc}

\subsection{\texttt{RR\_RECORD}}
\index{RR\_RECORD}
\texttt{RR\_RECORD} is for radiative recombination and photoionization data.

\begin{verbatim}
typedef struct _RR_RECORD_ {
  int b;
  int f;
  int kl;
  float *params;
  float *strength;
} RR_RECORD;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{int b}:] The bound state index.
\item[\texttt{int f}:] The free state index.
\item[\texttt{int kl}:] The orbital angular momentum of the ionized shell for
the dominant wavefunction component.
\item[\texttt{float *params}:] The parameters in the fitting formula for the
bound-free oscillator strength, if the FIT mode is
used. The fitting formula only provides a high energy asymptotic behavior. Low
energy values should be interpolated from the tabulated strengths. The fitting
formula is
\begin{eqnarray}
x &=& \frac{E_e+p_3}{p_3} \nonumber\\
y &=& \frac{1+p_2}{\sqrt{x}+p_2} \nonumber\\
\frac{d(gf)}{dE} &=&
\frac{E_\gamma}{E_e+p_3}p_0x^{-3.5-l+\frac{1}{2}p_1}y^{p_1}, 
\end{eqnarray}
where $E_e$ is the photo-electron energy, $E_\gamma$ is the photon energy,
$E_{th}$ is the ionization threshold, $p_0$, $p_1$, $p_2$, and $p_3$ are the
parameters, and $l$ is the orbital angular momentum of the ionized
shell. The asymptotic behavior represented by the power law only takes into
account the ionization of the dominant basis in the wavefunction
expansion. The result is in atomic unit Hartree$^{-1}$.
\item[\texttt{float *strength}:] The weighted bound-free oscillator strength in
atomic units. It is related to photoionization and radiative recombination as
(in atomic units):
\begin{eqnarray}
\sigma_{PI} &=& 2\pi\alpha\frac{d f}{d E} \nonumber\\
            &=& \frac{2\pi\alpha}{g_i}
		 \frac{1+\alpha^2\varepsilon}{1+\frac{1}{2}\alpha^2 \varepsilon}
		 \frac{d(gf)}{d E} \nonumber\\
\sigma_{RR} &=& \frac{\alpha^2}{2}\frac{g_i}{g_f}
                \frac{\omega^2}{\varepsilon \left(1+\frac{1}{2}\alpha^2
                  \varepsilon\right)} \sigma_{PI},
\end{eqnarray}
where $\alpha$ is the fine structure constant, $g_i$ and $g_f$ are the
statistical weight of the bound states before and after the photoionization
takes place respectively, $\omega$ is the photon energy, and $\varepsilon$ is
the energy of the ejected photo-electron. The tabulated values are $d(gf)/dE$.
\end{dbdesc}

\subsection{\texttt{AI\_HEADER}}
\index{AI\_HEADER}
\texttt{AI\_HEADER} is the data header for autoionization data blocks.

\begin{verbatim}
typedef struct _AI_HEADER_ {
  long position;
  long length;
  int nele;
  int ntransitions;
  int channel;
  int n_egrid;
  double *egrid;
} AI_HEADER;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{long position}:] The number of bytes from the beginning of the
file to the place where this data block starts.
\item[\texttt{long length}:] Number of bytes in this data block, excluding the
length of the header.
\item[\texttt{int nele}:] Number of electrons in the ion for this block.
\item[\texttt{int ntransitions}:] Number of transitions in this block.
\item[\texttt{int channel}:] This an identifier to label the autoionization
channel, which does not have specific physical meaning.
\item[\texttt{int n\_egrid}:] The number of points for the Auger electron
energy grid. The autoionization radial integrals are calculated on this grid
and interpolated to the actual discrete energies.
\item[\texttt{double *egrid}:] The energy grid. The number of elements is
given by \texttt{n\_egrid}.
\end{dbdesc}

\subsection{\texttt{AI\_RECORD}}
\index{AI\_RECORD}
\texttt{AI\_RECORD} is for autoionization data.

\begin{verbatim}
typedef struct _AI_RECORD_ {
  int b;
  int f;
  float rate;
} AI_RECORD;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{int b}:] The bound state index.
\item[\texttt{int f}:] The free state index.
\item[\texttt{float rate}:] The autoionization rate.
\end{dbdesc}

\subsection{\texttt{CI\_HEADER}}
\index{CI\_HEADER}
\texttt{CI\_HEADER} is the data header for collisional ionization data blocks.

\begin{verbatim}
typedef struct _CI_HEADER_ {
  long position;
  long length;
  int nele;
  int ntransitions;
  int qk_mode;
  int n_tegrid;
  int n_egrid;
  int egrid_type;
  int n_usr;
  int usr_egrid_type;
  int nparams;
  int pw_type;
  double *tegrid;
  double *egrid;
  double *usr_egrid;
} CI_HEADER;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{long position}:] The number of bytes from the beginning of the
file to the place where this data block starts.
\item[\texttt{long length}:] Number of bytes in this data block, excluding the
length of the header.
\item[\texttt{int nele}:] Number of electrons in the ion for this block.
\item[\texttt{int ntransitions}:] Number of transitions in this block.
\item[\texttt{int qk\_mode}:] The mode for the calculation of radial
integrals. At present, there are 3 choices. 3 for CB mode (Coulomb-Born), 4 for
DW mode (distorted-wave), and 5 for BED mode (binary-encounter-dipole). In CB
mode, the radial integrals are obtained by looking up a table of
Coulomb-Born-Exchange results from \citet{golden:1977a,golden:1980a}, which is
very fast. In DW mode, the integrals are calculated using the distorted-wave
approximation, which is very slow. In BED mode, the binary-encounter-dipole
theory of \citet{kim:1994a} is used which makes use of bound-free oscillator
strength of the same transition. This method is also very fast.
\item[\texttt{int n\_tegrid}:] Number of points for the transition energy grid.
\item[\texttt{int n\_egrid}:] Number of points for the collision energy grid.
\item[\texttt{int egrid\_type}:] Type of the energy grid. 0 for the incident
electron energy, 1 for the total energy of scattered and ejected electron.
\item[\texttt{int n\_usr}:]N umber of points for the user collision energy
grid.
\item[\texttt{int usr\_egrid\_type}:] Type of the user energy grid. 0 for the
incident electron energy, 1 for the total energy of scattered and ejected
electrons .
\item[\texttt{int nparams}:] Number of parameters in the fitting formula. The
final collision strength for total ionization cross sections are fitted with a
4 parameter formula.
\item[\texttt{int pw\_type}:] Partial wave type for the last summation. 0 for
the incident electron, 1 for the scattered electron. It is always 0 for
distorted-wave calculation of ionization.
\item[\texttt{double *tegrid}:] The transition energy grid, the number of
elements is given by \texttt{n\_tegrid}.
\item[\texttt{double *egrid}:] The energy grid, the number of elements is
given by \texttt{n\_egrid}.
\item[\texttt{double *usr\_egrid}:] The user energy grid, the number of
elements is given by \texttt{n\_usr}.
\end{dbdesc}

\subsection{\texttt{CI\_RECORD}}
\index{CI\_RECORD}
\texttt{CI\_RECORD} is for collisional ionization data.

\begin{verbatim}
typedef struct _CI_RECORD_ {
  int b;
  int f;
  int kl;
  float *params;
  float *strength;
} CI_RECORD;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{int b}:] The bound state index.
\item[\texttt{int f}:] The free state index.
\item[\texttt{int kl}:] The orbital angular momentum of the ionized shell for
the dominant wavefunction component.
\item[\texttt{float *params}:] The parameters in the fitting formula for the
collision strength. The number of elements is given by \texttt{nparams} in
\texttt{CI\_HEADER}, which is 4. The formula used is
\begin{eqnarray}
x &=& \frac{E_0}{E_{th}} \nonumber\\
y &=& 1-\frac{1}{x} \nonumber\\
\Omega &=& p_0\ln x + p_1y^2 + p_2\frac{1}{x}y + p_3\frac{1}{x^2}y,
\end{eqnarray}
where $E_0$ is the energy of the incident electron, $E_{th}$ is the ionization
threshold, $p_0$, $p_1$, $p_2$, and $p_3$ are the four parameters. The parameter
$p_0$ is actually obtained from the bound-free oscillator strength, which is
more reliable than one would get by fitting the calculated collision strengths.
\item[\texttt{float *strength}:] The collision strength for ionization. It is
related to the ionization cross section as (in atomic units):
\begin{equation}
\sigma = \frac{1}{k_0^2g_0}\Omega,
\end{equation}
where ${k_0}$ is the kinetic momentum of the incident electron, and $g_0$ is
the statistical weight of the initial state. The missing of the factor $\pi$
as compared to the formula for collisional excitation is due to the different
normalization for bound and free states.
\end{dbdesc}

\subsection{\texttt{AIM\_HEADER}}
\index{AIM\_HEADER}
\begin{verbatim}
typedef struct _AIM_HEADER_ {
  long int position;
  long int length;
  int nele;
  int ntransitions;
  int channel;
  int n_egrid;
  double *egrid;
} AIM_HEADER;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{long position}:] The number of bytes from the beginning of the
file to the place where this data block starts.
\item[\texttt{long length}:] Number of bytes in this data block, excluding the
length of the header.
\item[\texttt{int nele}:] Number of electrons in the ion for this block.
\item[\texttt{int ntransitions}:] Number of transitions in this block.
\item[\texttt{int channel}:] This an identifier to label the autoionization
channel, which does not have specific physical meaning.
\item[\texttt{int n\_egrid}:] The number of points for the Auger electron
energy grid. The autoionization radial integrals are calculated on this grid
and interpolated to the actual discrete energies.
\item[\texttt{double *egrid}:] The energy grid. The number of elements is
given by \texttt{n\_egrid}.
\end{dbdesc}

\subsection{\texttt{AIM\_RECORD}}
\index{AIM\_RECORD}
\begin{verbatim}
typedef struct _AIM_RECORD_ {
  int b;
  int f;
  int nsub;
  float *rate;
} AIM_RECORD;
\end{verbatim}
\begin{dbdesc}
\item[\texttt{int b}:] The bound state index.
\item[\texttt{int f}:] The free state index.
\item[\texttt{int nsub}:] The number of entries in array \texttt{rate}. It is
twice the number of transitions tabulated, because both autoionization and DR
capture strength need to be stored. 
\item[\texttt{float *rate}:] An array containing magnetic sublevel
autoionization rates and DR capture strength. Suppose $A(M_1,M_2)$ represents
autoionization rate from $M_1$ sublevel of \texttt{b} to $M_2$ sublevel of
\texttt{f}, and $R(M_1,M_2)$ is capture strength from $M_2$ sublevel of
\texttt{f} to $M_1$ sublevel of \texttt{b}. Then the array \texttt{rate} is
generated in the order consistent with the following code:
\begin{verbatim}
t = 0
for (M1 = -J1; M1 <= 0; M1++) {
  for (M2 = -J2; M2 <= J2; M2++) {
     rate[t++] = A(M1,M2);
     rate[t++] = R(M1,M2);
  }
}
\end{verbatim}
Due to axial symmetry, values for $M_1 > 0$ can be obtained from those with
$M_1 \le 0$.
\end{dbdesc}

\subsection{\texttt{CIM\_HEADER}}
\index{CIM\_HEADER}
\texttt{CIM\_HEADER} is the data header for magnetic sublevel collisional
ionization data blocks. 

\begin{verbatim}
typedef struct _CIM_HEADER_ {
  long position;
  long length;
  int nele;
  int ntransitions;
  int n_egrid;
  int egrid_type;
  int n_usr;
  int usr_egrid_type;
  double *egrid;
  double *usr_egrid;
} CIM_HEADER;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{long position}:] The number of bytes from the beginning of the
file to the place where this data block starts.
\item[\texttt{long length}:] Number of bytes in this data block, excluding the
length of the header.
\item[\texttt{int nele}:] Number of electrons in the ion for this block.
\item[\texttt{int ntransitions}:] Number of transitions in this block.
\item[\texttt{int n\_egrid}:] Number of points for the collision energy grid.
\item[\texttt{int egrid\_type}:] Type of the energy grid. 0 for the incident
electron energy, 1 for the total energy of scattered and ejected electron.
\item[\texttt{int n\_usr}:]N umber of points for the user collision energy
grid.
\item[\texttt{int usr\_egrid\_type}:] Type of the user energy grid. 0 for the
incident electron energy, 1 for the total energy of scattered and ejected
electrons .
\item[\texttt{double *tegrid}:] The transition energy grid, the number of
elements is given by \texttt{n\_tegrid}.
\item[\texttt{double *egrid}:] The energy grid, the number of elements is
given by \texttt{n\_egrid}.
\item[\texttt{double *usr\_egrid}:] The user energy grid, the number of
elements is given by \texttt{n\_usr}.
\end{dbdesc}

\subsection{\texttt{CIM\_RECORD}}
\index{CIM\_RECORD}
\texttt{CIM\_RECORD} is for magnetic sublevel collisional ionization data.

\begin{verbatim}
typedef struct _CIM_RECORD_ {
  int b;
  int f;
  int nsub;
  float *strength;
} CIM_RECORD;
\end{verbatim}

\begin{dbdesc}
\item[\texttt{int b}:] The bound state index.
\item[\texttt{int f}:] The free state index.
\item[\texttt{int nusb}:] The number of sublevel transitions in the
  \texttt{strength} array. 
\item[\texttt{float *strength}:] The magnetic sublevel collision strength for
  ionization. It is related to the ionization cross section as (in atomic
  units): 
\begin{equation}
\sigma = \frac{1}{k_0^2}\Omega,
\end{equation}
where ${k_0}$ is the kinetic momentum of the incident electron. The different
magnetic sublevel transitions are arranged in the order similar to those for
excitation, i.e., $-J_i\to -J_f$, $-J_i\to -J_f+1$, $\cdots$, $-J_i\to J_f$,
$-J_i+1\to -J_f$, $-J_i+1\to -J_f+1$, $\cdots$, $-J_i+1\to J_f$,
$\cdots$. Only the cross sections with $M_i \le 0$ are included, since those
with $M_i \ge 0$ can be obtained using time reversal symmetry.

\end{dbdesc}


\section{ASCII Format}
\cFAC provides functions to convert the binary output to ASCII files. There are
two types of ASCII formats, a simple translation of binary files and a more
verbose version that adds more derived information for the sake of
convenience. If the ASCII files are created to be human-readable, the
verbose form should be used.

In the simple form, the contents of binary files are converted to ASCII format
as is. No additional information is added. All physical values are in atomic
units as is in binary files. The different byte-order used by different
platforms are taken into account automatically. Therefore, it is possible to
create the binary files on a little endian machine (probably faster), then
convert them to ASCII format on a slower big endian machine.

In the verbose form, the more common units of physical quantities are
used. Specifically, s$^{-1}$ for transition rates, 10$^{-20}$ cm$^2$ for cross
sections, and eV for energies. For data files other than \texttt{DB\_EN} type,
the energies and angular momenta of the levels involved in the processes are
not included in the binary version. In the verbose form of corresponding ASCII
files, this information is added by looking up in the energy level
table. Also, for \texttt{DB\_TR} files, not only matrix elements, but also
$gf$ values and radiative transition rates are tabulated. For \texttt{DB\_CE}
and \texttt{DB\_CI}, cross
sections are tabulated along with the collision strengths. For \texttt{DB\_RR},
radiative recombination and photoionization cross sections are tabulated along
with the bound-free differential $gf$ values. For \texttt{DB\_AI}, the energy
integrated dielectronic capture strengths (in unit of 10$^{-20}$ eV cm$^2$)
are tabulated in addition to the autoionization rates.

In the following sections, a portion of each type of database file in the
verbose form is listed and significant fields explained. The lines start with
a ``\verb|#|'' are the added explanation, which are not part of the output
file. These files are generated with the scripts in the \texttt{demo/}
directory come with \cFAC.

\subsection{\texttt{DB\_EN}}
\index{DB\_EN}
\begin{verbatim}
# version numbers
FAC 1.0.4
# binary order used in the binary file
Endian	= 0
# time stamp when the file was created.
TSess	= 1020438482
# database type
Type	= 1
# this file is in verbose form
Verbose	= 1
# atomic symbol and atomic number
Fe Z	= 26.0
# number of data blocks in this file
NBlocks	= 1
# the index and the absolute energy of the ground state
E0	= 0, -3.12494784E+04

# data block begins
# number of electron for the states in this block
NELE	= 10
# number of levels in this block
NLEV	= 37
  ILEV  IBASE    ENERGY       P   VNL 2J
     0     -1  0.00000000E+00 0   201  0 1*2 2*8      2p6      2p+4(0)0 
     1     -1  7.23810448E+02 1   300  4 1*2 2*7 3*1  2p5 3s1  2p+3(3)3 3s+1(1)4 
     2     -1  7.25859655E+02 1   300  2 1*2 2*7 3*1  2p5 3s1  2p+3(3)3 3s+1(1)2 
     3     -1  7.36414516E+02 1   300  0 1*2 2*7 3*1  2p5 3s1  2p-1(1)1 3s+1(1)0 
     4     -1  7.37736604E+02 1   300  2 1*2 2*7 3*1  2p5 3s1  2p-1(1)1 3s+1(1)2 
     5     -1  7.54149163E+02 0   301  2 1*2 2*7 3*1  2p5 3p1  2p+3(3)3 3p-1(1)2 
     6     -1  7.57788593E+02 0   301  4 1*2 2*7 3*1  2p5 3p1  2p+3(3)3 3p-1(1)4 
     7     -1  7.59341459E+02 0   301  6 1*2 2*7 3*1  2p5 3p1  2p+3(3)3 3p+1(3)6 
     8     -1  7.60552577E+02 0   301  2 1*2 2*7 3*1  2p5 3p1  2p+3(3)3 3p+1(3)2 
     9     -1  7.62361512E+02 0   301  4 1*2 2*7 3*1  2p5 3p1  2p+3(3)3 3p+1(3)4 
    10     -1  7.67999430E+02 0   301  0 1*2 2*7 3*1  2p5 3p1  2p+3(3)3 3p+1(3)0 
   ......
\end{verbatim}

The column labels by \verb|VNL| is $100\times n + l$, where $n$ and $l$ 
are the principle and orbital angular quantum numbers of the valence 
electron.

\subsection{\texttt{DB\_TR}}
\index{DB\_TR}
\begin{verbatim}
FAC 1.0.7
Endian	= 0
TSess	= 1021577025
Type	= 2
Verbose	= 1
Fe Z	=  26.0
NBlocks	= 1

# the data block begins
NELE	= 10
# number of transitions in this block
NTRANS	= 7
# multipole type of the transition
Multip	= -1
# gauge used in the calculation
Gauge	= 2
# mode used in the radial integral
Mode	= 1
#upper 2J  lower 2J  Delta E     gf            TR rate(1/s)  multipole
     2  2      0  0  7.2587E+02  1.130597E-01  8.616084E+11  1.127617E-01
     4  2      0  0  7.3774E+02  9.944485E-02  7.828559E+11  1.048997E-01
    16  2      0  0  8.0114E+02  9.438239E-03  8.761793E+10 -3.101188E-02
    22  2      0  0  8.1133E+02  6.221187E-01  5.923155E+12 -2.501928E-01
    26  2      0  0  8.2527E+02  2.493449E+00  2.456309E+13  4.966355E-01
    30  2      0  0  8.9415E+02  3.203146E-02  3.704097E+11  5.407792E-02
    32  2      0  0  8.9844E+02  2.652003E-01  3.096259E+12 -1.552313E-01
\end{verbatim}

After version 1.0.8, if the UTA mode is used, the output contains an
additional column after the transition energy, which is the Gaussian standard
deviation of the UTA transition. The $2J$ values in this case are also
redefined to be the statistical weight of the configuration minus 1.

\subsection{\texttt{DB\_CE}}
\index{DB\_CE}
\begin{verbatim}
FAC 0.7.9
Endian	= 0
TSess	= 1021577097
Type	= 3
Verbose	= 1
Fe Z	=  26.0
NBlocks	= 1

# data blocks begin
NELE	= 10
NTRANS	= 36
# mode used in the radial integral
QKMODE	= 0
# number of parameters in the fitting formula (only if QKMODE = 2)
NPARAMS	= 0
# 0 for total collision strength. 1 for magnetic sublevel.
MSUB	= 0
# partial wave summation mode. always 0. 
PWTYPE	= 0
# number of points in the transition energy grid, followed by the grid
NTEGRID	= 2
	  7.24352072E+02
	  9.45773957E+02
# characteristic transition energy used in grid construction.
TE0	=  9.44829120E+02
# energy grid type. 
ETYPE	= 1
# energy grid
NEGRID	= 6
	  4.72414560E+01
	  5.79761386E+02
	  1.39812537E+03
	  2.65576771E+03
	  4.58848260E+03
	  7.55863296E+03
# user energy grid type and the user grid.
UTYPE	= 1
NUSR	= 6
	  4.72414560E+01
	  5.79761386E+02
	  1.39812537E+03
	  2.65576771E+03
	  4.58848260E+03
	  7.55863296E+03
#lower 2J upper 2J Delta E  nsub
    0	 0	    1	 4	 7.2435E+02	1
#The Bethe coefficient and 2 Born coefficients in the Born approximation.
-1.0000E+00  0.0000E+00  0.0000E+00
# if QKMODE = 2, the parameter line is present here.
#user egrid  coll. str.  cross sec.
 4.7241E+01	 1.5347E-03	 2.3789E-01
 5.7976E+02	 9.5137E-04	 8.7207E-02
 1.3981E+03	 5.1906E-04	 2.9211E-02
 2.6558E+03	 2.5016E-04	 8.8294E-03
 4.5885E+03	 1.1322E-04	 2.5376E-03
 7.5586E+03	 5.1291E-05	 7.3523E-04
    0	 0	    2	 2	 7.2639E+02	1
 9.1750E-03 -7.0392E-03  7.2655E-03
 4.7241E+01	 1.8857E-03	 2.9153E-01
 5.7976E+02	 3.7280E-03	 3.4119E-01
 1.3981E+03	 6.3378E-03	 3.5633E-01
 2.6558E+03	 9.4893E-03	 3.3472E-01
 4.5885E+03	 1.2996E-02	 2.9116E-01
 7.5586E+03	 1.6729E-02	 2.3974E-01
 ......
\end{verbatim}

If \texttt{MSUB} = 1, then the data for each transition contains \texttt{nsub}
blocks, representing several $m_i\to m_f$ transitions. Before each block, the
ratio of the magnetic sublevel collision strengths to the total collision
strength at high energy limit is given. Due to the time
reversal symmetry, the cross section for $-m_i \to -m_f$ is the same as that
for $m_i \to m_j$, only the cross sections with $m_i \le 0$ are tabulated in
the order $-J_i\to -J_f$, $-J_i\to -J_f+1$, $\cdots$, $-J_i\to J_f$,
$-J_i+1\to -J_f$, $-J_i+1\to -J_f+1$, $\cdots$, $-J_i+1\to J_f$, $\cdots$.


\subsection{\texttt{DB\_RR}}
\index{DB\_RR}
\begin{verbatim}
FAC 0.7.3
Endian	= 0
TSess	= 1021577047
Type	= 4
Verbose	= 1
Fe Z	=  26.0
NBlocks	= 1

# the data blocks begin
NELE	= 3
NTRANS	= 3
QKMODE	= 2
# multipole type
MULTIP	= -1
# number of parameters in the fitting formula
NPARAMS	= 4
NTEGRID	= 1
	  2.01377924E+03
ETYPE	= 1
NEGRID	= 6
	  1.00688962E+02
	  1.23568529E+03
	  2.97992069E+03
	  5.66042025E+03
	  9.77974833E+03
	  1.61102339E+04
UTYPE	= 1
NUSR	= 6
	  1.00688962E+02
	  1.23568529E+03
	  2.97992069E+03
	  5.66042025E+03
	  9.77974833E+03
	  1.61102339E+04
#bound 2J  free 2J  Delta E    L 
    7	 1	    0	 0	 2.0465E+03	 0
# the parameters in the fitting formula
 3.8124E-02  4.9724E+00  1.2195E+00  2.1768E+03 
#user egrid RR cross sec. PI cross sec. gf
 1.0069E+02	 1.7567E-01	 1.9604E+00	 3.0537E-02
 1.2357E+03	 1.4375E-02	 8.4255E-01	 1.3124E-02
 2.9799E+03	 5.5123E-03	 3.3223E-01	 5.1751E-03
 5.6604E+03	 2.4847E-03	 1.2100E-01	 1.8848E-03
 9.7797E+03	 1.1476E-03	 4.1004E-02	 6.3872E-04
 1.6110E+04	 5.2175E-04	 1.3029E-02	 2.0295E-04
    8	 1	    0	 0	 1.9975E+03	 1
 3.4223E-02  5.3145E+00  1.2206E+00  2.1537E+03 
 1.0069E+02	 1.5214E-01	 1.7781E+00	 2.7697E-02
 1.2357E+03	 8.4472E-03	 5.1024E-01	 7.9480E-03
 2.9799E+03	 2.1814E-03	 1.3407E-01	 2.0885E-03
 5.6604E+03	 6.5910E-04	 3.2509E-02	 5.0639E-04
 9.7797E+03	 2.0448E-04	 7.3672E-03	 1.1476E-04
 1.6110E+04	 6.2231E-05	 1.5624E-03	 2.4338E-05
    9	 3	    0	 0	 1.9810E+03	 1
 6.9754E-02  5.1620E+00  1.2206E+00  2.1350E+03 
 1.0069E+02	 2.9691E-01	 1.7625E+00	 5.4910E-02
 1.2357E+03	 1.6320E-02	 4.9796E-01	 1.5513E-02
 2.9799E+03	 4.1721E-03	 1.2907E-01	 4.0209E-03
 5.6604E+03	 1.2475E-03	 3.0899E-02	 9.6262E-04
 9.7797E+03	 3.8274E-04	 6.9143E-03	 2.1541E-04
 1.6110E+04	 1.1506E-04	 1.4471E-03	 4.5081E-05
\end{verbatim}

\subsection{\texttt{DB\_AI}}
\index{DB\_AI}
\begin{verbatim}
FAC 0.7.3
Endian	= 0
TSess	= 1021577153
Type	= 5
Verbose	= 1
Se Z	=  34.0
NBlocks	= 1

# data blocks begin
NELE	= 10
# number of transitions
NTRANS	= 92
# channel number (no physical meaning)
CHANNE	= 0
# free electron energy grid
NEGRID	= 2
	  3.43213508E+02
	  5.58605513E+02
#bound 2J free 2J  Delta E     AI rate    DC strength
    2	 4    0	 3	 3.8679E+02	 1.3705E+13	 1.0962E+01
    2	 4    1	 1	 3.4322E+02	 1.6996E+11	 3.0642E-01
    3	 0    0	 3	 4.0594E+02	 1.2973E+13	 1.9775E+00
    3	 0    1	 1	 3.6236E+02	 7.9903E+11	 2.7289E-01
    4	 4    0	 3	 4.1845E+02	 2.3652E+11	 1.7487E-01
    4	 4    1	 1	 3.7487E+02	 2.2905E+09	 3.7807E-03
    ......
\end{verbatim}

\subsection{\texttt{DB\_CI}}
\index{DB\_CI}
\begin{verbatim}
FAC 0.7.3
Endian	= 0
TSess	= 1021577194
Type	= 6
Verbose	= 1
Fe Z	=  26.0
NBlocks	= 1

# data blocks begin
NELE	= 10
NTRANS	= 3
QKMODE	= 5
NPARAMS	= 4
PWTYPE	= 0
NTEGRID	= 2
	  1.26072567E+03
	  1.39546596E+03
ETYPE	= 1
NEGRID	= 6
	  6.64047908E+01
	  8.14939607E+02
	  1.96527014E+03
	  3.73307079E+03
	  6.44978485E+03
	  1.06247665E+04
UTYPE	= 1
NUSR	= 8
	  5.00000000E+02
	  9.00000000E+02
	  1.30000000E+03
	  1.70000000E+03
	  2.10000000E+03
	  4.20000000E+03
	  6.00000000E+03
	  8.00000000E+03
#bound 2J  free 2J  Delta E    L
    0	 0	    1	 3	 1.2607E+03	 1
# parameters in the fitting formula
 1.2549E-01  6.7308E-01 -5.4651E-01  7.2856E-01 
#user egrid  coll. str.  cross sec.
 5.0000E+02	 9.0588E-02	 1.9535E+00
 9.0000E+02	 1.5721E-01	 2.7605E+00
 1.3000E+03	 2.1672E-01	 3.2084E+00
 1.7000E+03	 2.6991E-01	 3.4532E+00
 2.1000E+03	 3.1773E-01	 3.5785E+00
 4.2000E+03	 5.0773E-01	 3.5050E+00
 6.0000E+03	 6.1976E-01	 3.2065E+00
 8.0000E+03	 7.1292E-01	 2.8808E+00
    0	 0	    2	 1	 1.2737E+03	 1
 6.3179E-02  3.3088E-01 -2.6847E-01  3.5591E-01 
 5.0000E+02	 4.4336E-02	 9.4904E-01
 9.0000E+02	 7.7083E-02	 1.3454E+00
 1.3000E+03	 1.0639E-01	 1.5671E+00
 1.7000E+03	 1.3263E-01	 1.6894E+00
 2.1000E+03	 1.5624E-01	 1.7529E+00
 4.2000E+03	 2.5023E-01	 1.7233E+00
 6.0000E+03	 3.0577E-01	 1.5791E+00
 8.0000E+03	 3.5203E-01	 1.4205E+00
    0	 0	    3	 1	 1.3955E+03	 0
 5.7526E-02  2.8628E-01 -2.4531E-01  3.1267E-01 
 5.0000E+02	 3.4409E-02	 6.8908E-01
 9.0000E+02	 6.0280E-02	 9.9604E-01
 1.3000E+03	 8.4082E-02	 1.1823E+00
 1.7000E+03	 1.0585E-01	 1.2950E+00
 2.1000E+03	 1.2576E-01	 1.3615E+00
 4.2000E+03	 2.0705E-01	 1.3946E+00
 6.0000E+03	 2.5609E-01	 1.3005E+00
 8.0000E+03	 2.9733E-01	 1.1840E+00
\end{verbatim}

\section{SQLite Format}
\label{sec:sqlite}

The SQLite format is that of the SQLite SQL database engine~\cite{sqlite}. In
order to use it, (i) call \funcref{StoreInit}, (ii) call \funcref{StoreTable}
every time when \funcref{PrintTable} would have been used for the ASCII output,
and finally, (iii) call \funcref{StoreClose}. Please note that if desired, ASCII
and SQLite data can be output simultaneously.

The SQL scheme used by \cFAC to store the data in this format is listed below.

\lstset{caption=SQL schema}
\includecode[sql]{../faclib/schema.sql}

However, it is not expected to be used directly; instead, the CFACDB library,
which is part of the \cFAC distribution, is provided. The library hides all the
complexity of working with an SQL database behind a simple application
programming interface (API). The API is available both for C and Fortran
programming languages. The data are returned via user-provided ``sink'' callback
routines. An F77 demo program is shown in the listing below.

\lstset{language=[77]Fortran,numbers=left,caption=An F77 demo}
\lstinputlisting{../cfacdb/fdemo.f}
